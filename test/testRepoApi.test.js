// Import the dependencies for testing
const chai = require('chai');
const chaiHttp = require('chai-http');
const db = require('../src/db');
const service = require('../src/service');
const { getAllProxiedHosts } = require('../src/proxy/routes/helper');

import Proxy from '../src/proxy';

chai.use(chaiHttp);
chai.should();
const expect = chai.expect;

const TEST_REPO = {
  url: 'https://github.com/finos/test-repo.git',
  name: 'test-repo',
  project: 'finos',
  host: 'github.com',
};

const TEST_REPO_NON_GITHUB = {
  url: 'https://gitlab.com/org/sub-org/test-repo2.git',
  name: 'test-repo2',
  project: 'org/sub-org',
  host: 'gitlab.com',
};

const TEST_REPO_NAKED = {
  url: 'https://123.456.789:80/test-repo3.git',
  name: 'test-repo3',
  project: '',
  host: '123.456.789:80',
};

const cleanupRepo = async (url) => {
  const repo = await db.getRepoByUrl(url);
  if (repo) {
    await db.deleteRepo(repo._id);
  }
};

describe('add new repo', async () => {
  let app;
  let proxy;
  let cookie;
  const repoIds = [];

  const setCookie = function (res) {
    res.headers['set-cookie'].forEach((x) => {
      if (x.startsWith('connect')) {
        const value = x.split(';')[0];
        cookie = value;
      }
    });
  };

  before(async function () {
    proxy = new Proxy();
    app = await service.start(proxy);
    // Prepare the data.
    // _id is autogenerated by the DB so we need to retrieve it before we can use it
    cleanupRepo(TEST_REPO.url);
    cleanupRepo(TEST_REPO_NON_GITHUB.url);
    cleanupRepo(TEST_REPO_NAKED.url);

    await db.deleteUser('u1');
    await db.deleteUser('u2');
    await db.createUser('u1', 'abc', 'test@test.com', 'test', true);
    await db.createUser('u2', 'abc', 'test2@test.com', 'test', true);
  });

  it('login', async function () {
    const res = await chai.request(app).post('/api/auth/login').send({
      username: 'admin',
      password: 'admin',
    });
    expect(res).to.have.cookie('connect.sid');
    setCookie(res);
  });

  it('create a new repo', async function () {
    const res = await chai
      .request(app)
      .post('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .send(TEST_REPO);
    res.should.have.status(200);

    const repo = await db.getRepoByUrl(TEST_REPO.url);
    // save repo id for use in subsequent tests
    repoIds[0] = repo._id;

    repo.project.should.equal(TEST_REPO.project);
    repo.name.should.equal(TEST_REPO.name);
    repo.url.should.equal(TEST_REPO.url);
    repo.users.canPush.length.should.equal(0);
    repo.users.canAuthorise.length.should.equal(0);
  });

  it('get a repo', async function () {
    const res = await chai
      .request(app)
      .get('/api/v1/repo/' + repoIds[0])
      .set('Cookie', `${cookie}`)
      .send();
    res.should.have.status(200);

    expect(res.body.url).to.equal(TEST_REPO.url);
    expect(res.body.name).to.equal(TEST_REPO.name);
    expect(res.body.project).to.equal(TEST_REPO.project);
  });

  it('return a 409 error if the repo already exists', async function () {
    const res = await chai
      .request(app)
      .post('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .send(TEST_REPO);
    res.should.have.status(409);
    res.body.message.should.equal('Repository ' + TEST_REPO.url + ' already exists!');
  });

  it('filter repos', async function () {
    const res = await chai
      .request(app)
      .get('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .query({ url: TEST_REPO.url });
    res.should.have.status(200);
    res.body[0].project.should.equal(TEST_REPO.project);
    res.body[0].name.should.equal(TEST_REPO.name);
    res.body[0].url.should.equal(TEST_REPO.url);
  });

  it('add 1st can push user', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u1',
      });

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canPush.length.should.equal(1);
    repo.users.canPush[0].should.equal('u1');
  });

  it('add 2nd can push user', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u2',
      });

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canPush.length.should.equal(2);
    repo.users.canPush[1].should.equal('u2');
  });

  it('add push user that does not exist', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u3',
      });

    res.should.have.status(400);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canPush.length.should.equal(2);
  });

  it('delete user u2 from push', async function () {
    const res = await chai
      .request(app)
      .delete(`/api/v1/repo/${repoIds[0]}/user/push/u2`)
      .set('Cookie', `${cookie}`)
      .send({});

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canPush.length.should.equal(1);
  });

  it('add 1st can authorise user', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u1',
      });

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canAuthorise.length.should.equal(1);
    repo.users.canAuthorise[0].should.equal('u1');
  });

  it('add 2nd can authorise user', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u2',
      });

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canAuthorise.length.should.equal(2);
    repo.users.canAuthorise[1].should.equal('u2');
  });

  it('add authorise user that does not exist', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', `${cookie}`)
      .send({
        username: 'u3',
      });

    res.should.have.status(400);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canAuthorise.length.should.equal(2);
  });

  it('Can delete u2 user', async function () {
    const res = await chai
      .request(app)
      .delete(`/api/v1/repo/${repoIds[0]}/user/authorise/u2`)
      .set('Cookie', `${cookie}`)
      .send({});

    res.should.have.status(200);
    const repo = await db.getRepoById(repoIds[0]);
    repo.users.canAuthorise.length.should.equal(1);
  });

  it('Valid user push permission on repo', async function () {
    const res = await chai
      .request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', `${cookie}`)
      .send({ username: 'u2' });

    res.should.have.status(200);
    const isAllowed = await db.isUserPushAllowed(TEST_REPO.url, 'u2');
    expect(isAllowed).to.be.true;
  });

  it('Invalid user push permission on repo', async function () {
    const isAllowed = await db.isUserPushAllowed(TEST_REPO.url, 'test1234');
    expect(isAllowed).to.be.false;
  });

  it('Proxy route helpers should return the proxied origin', async function () {
    const origins = await getAllProxiedHosts();
    expect(origins).to.eql([TEST_REPO.host]);
  });

  it('Proxy route helpers should return the new proxied origins when new repos are added', async function () {
    const res = await chai
      .request(app)
      .post('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .send(TEST_REPO_NON_GITHUB);
    res.should.have.status(200);

    const repo = await db.getRepoByUrl(TEST_REPO_NON_GITHUB.url);
    // save repo id for use in subsequent tests
    repoIds[1] = repo._id;

    repo.project.should.equal(TEST_REPO_NON_GITHUB.project);
    repo.name.should.equal(TEST_REPO_NON_GITHUB.name);
    repo.url.should.equal(TEST_REPO_NON_GITHUB.url);
    repo.users.canPush.length.should.equal(0);
    repo.users.canAuthorise.length.should.equal(0);

    const origins = await getAllProxiedHosts();
    expect(origins).to.have.members([TEST_REPO.host, TEST_REPO_NON_GITHUB.host]);

    const res2 = await chai
      .request(app)
      .post('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .send(TEST_REPO_NAKED);
    res2.should.have.status(200);
    const repo2 = await db.getRepoByUrl(TEST_REPO_NAKED.url);
    repoIds[2] = repo2._id;

    const origins2 = await getAllProxiedHosts();
    expect(origins2).to.have.members([
      TEST_REPO.host,
      TEST_REPO_NON_GITHUB.host,
      TEST_REPO_NAKED.host,
    ]);
  });

  it('delete a repo', async function () {
    const res = await chai
      .request(app)
      .delete('/api/v1/repo/' + repoIds[1] + '/delete')
      .set('Cookie', `${cookie}`)
      .send();
    res.should.have.status(200);

    const repo = await db.getRepoByUrl(TEST_REPO_NON_GITHUB.url);
    expect(repo).to.be.null;

    const res2 = await chai
      .request(app)
      .delete('/api/v1/repo/' + repoIds[2] + '/delete')
      .set('Cookie', `${cookie}`)
      .send();
    res2.should.have.status(200);

    const repo2 = await db.getRepoByUrl(TEST_REPO_NAKED.url);
    expect(repo2).to.be.null;
  });

  after(async function () {
    await service.httpServer.close();

    // don't clean up data as cypress tests rely on it being present
    // await cleanupRepo(TEST_REPO.url);
    // await db.deleteUser('u1');
    // await db.deleteUser('u2');

    await cleanupRepo(TEST_REPO_NON_GITHUB.url);
    await cleanupRepo(TEST_REPO_NAKED.url);
  });
});
