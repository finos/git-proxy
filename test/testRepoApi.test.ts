import request from 'supertest';
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import * as db from '../src/db';
import { Service } from '../src/service';

import { Proxy } from '../src/proxy';
import { getAllProxiedHosts } from '../src/db';

const TEST_REPO = {
  url: 'https://github.com/finos/test-repo.git',
  name: 'test-repo',
  project: 'finos',
  host: 'github.com',
};

const TEST_REPO_NON_GITHUB = {
  url: 'https://gitlab.com/org/sub-org/test-repo2.git',
  name: 'test-repo2',
  project: 'org/sub-org',
  host: 'gitlab.com',
};

const TEST_REPO_NAKED = {
  url: 'https://123.456.789:80/test-repo3.git',
  name: 'test-repo3',
  project: '',
  host: '123.456.789:80',
};

const cleanupRepo = async (url: string) => {
  const repo = await db.getRepoByUrl(url);
  if (repo) {
    await db.deleteRepo(repo._id!);
  }
};

const fetchRepoOrThrow = async (url: string) => {
  const repo = await db.getRepoByUrl(url);
  if (!repo) {
    throw new Error('Repo not found');
  }
  return repo;
};

describe('add new repo', () => {
  let app: any;
  let proxy: any;
  let cookie: string;
  const repoIds: string[] = [];

  const setCookie = function (res: any) {
    res.headers['set-cookie'].forEach((x: string) => {
      if (x.startsWith('connect')) {
        const value = x.split(';')[0];
        cookie = value;
      }
    });
  };

  const ensureTestRepoExists = async () => {
    let repo = await db.getRepoByUrl(TEST_REPO.url);
    if (!repo) {
      await request(app).post('/api/v1/repo').set('Cookie', `${cookie}`).send(TEST_REPO);
      repo = await db.getRepoByUrl(TEST_REPO.url);
    }
    if (repo) repoIds[0] = repo._id!;
    return repo;
  };

  const ensureUsersCanPush = async (users: string[]) => {
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    for (const user of users) {
      if (!repo.users.canPush.includes(user)) await db.addUserCanPush(repoIds[0], user);
    }
  };

  const ensureUsersCanAuthorise = async (users: string[]) => {
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    for (const user of users) {
      if (!repo.users.canAuthorise.includes(user)) await db.addUserCanAuthorise(repoIds[0], user);
    }
  };

  beforeAll(async () => {
    proxy = new Proxy();
    app = await Service.start(proxy);
    // Prepare the data.
    // _id is autogenerated by the DB so we need to retrieve it before we can use it
    await cleanupRepo(TEST_REPO.url);
    await cleanupRepo(TEST_REPO_NON_GITHUB.url);
    await cleanupRepo(TEST_REPO_NAKED.url);

    await db.deleteUser('u1');
    await db.deleteUser('u2');
    await db.createUser('u1', 'abc', 'test@test.com', 'test', true);
    await db.createUser('u2', 'abc', 'test2@test.com', 'test', true);

    // Login once in beforeAll
    const res = await request(app).post('/api/auth/login').send({
      username: 'admin',
      password: 'admin',
    });
    setCookie(res);
  });

  it('create a new repo', async () => {
    // Ensure repo doesn't exist
    await cleanupRepo(TEST_REPO.url);

    const res = await request(app).post('/api/v1/repo').set('Cookie', `${cookie}`).send(TEST_REPO);
    expect(res.status).toBe(200);

    const repo = await fetchRepoOrThrow(TEST_REPO.url);

    // save repo id for use in subsequent tests
    repoIds[0] = repo._id!;

    expect(repo.project).toBe(TEST_REPO.project);
    expect(repo.name).toBe(TEST_REPO.name);
    expect(repo.url).toBe(TEST_REPO.url);
    expect(repo.users.canPush.length).toBe(0);
    expect(repo.users.canAuthorise.length).toBe(0);
  });

  it('get a repo', async () => {
    await ensureTestRepoExists();

    const res = await request(app)
      .get('/api/v1/repo/' + repoIds[0])
      .set('Cookie', `${cookie}`);
    expect(res.status).toBe(200);

    expect(res.body.url).toBe(TEST_REPO.url);
    expect(res.body.name).toBe(TEST_REPO.name);
    expect(res.body.project).toBe(TEST_REPO.project);
  });

  it('return a 409 error if the repo already exists', async () => {
    await ensureTestRepoExists();

    const res = await request(app).post('/api/v1/repo').set('Cookie', `${cookie}`).send(TEST_REPO);
    expect(res.status).toBe(409);
    expect(res.body.message).toBe('Repository ' + TEST_REPO.url + ' already exists!');
  });

  it('filter repos', async () => {
    await ensureTestRepoExists();

    const res = await request(app)
      .get('/api/v1/repo')
      .set('Cookie', `${cookie}`)
      .query({ url: TEST_REPO.url });
    expect(res.status).toBe(200);
    expect(res.body[0].project).toBe(TEST_REPO.project);
    expect(res.body[0].name).toBe(TEST_REPO.name);
    expect(res.body[0].url).toBe(TEST_REPO.url);
  });

  it('add 1st can push user', async () => {
    await ensureTestRepoExists();

    // Reset push users for this test
    const repoBefore = await fetchRepoOrThrow(TEST_REPO.url);
    for (const user of repoBefore.users.canPush) {
      await db.removeUserCanPush(repoIds[0], user);
    }

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({ username: 'u1' });

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canPush.length).toBe(1);
    expect(repo.users.canPush[0]).toBe('u1');
  });

  it('add 2nd can push user', async () => {
    await ensureTestRepoExists();

    // Ensure u1 is already a push user, then add u2
    await ensureUsersCanPush(['u1']);

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({ username: 'u2' });

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canPush).toContain('u1');
    expect(repo.users.canPush).toContain('u2');
    expect(repo.users.canPush.length).toBe(2);
  });

  it('add push user that does not exist', async () => {
    await ensureTestRepoExists();

    // Ensure 2 push users exist
    await ensureUsersCanPush(['u1', 'u2']);

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/push`)
      .set('Cookie', `${cookie}`)
      .send({ username: 'u3' });

    expect(res.status).toBe(400);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canPush.length).toBe(2);
  });

  it('delete user u2 from push', async () => {
    await ensureTestRepoExists();

    // Ensure u1 and u2 are push users
    await ensureUsersCanPush(['u1', 'u2']);

    const res = await request(app)
      .delete(`/api/v1/repo/${repoIds[0]}/user/push/u2`)
      .set('Cookie', `${cookie}`)
      .send({});

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canPush.length).toBe(1);
  });

  it('add 1st can authorise user', async () => {
    await ensureTestRepoExists();

    // Reset authorise users
    const repoBefore = await fetchRepoOrThrow(TEST_REPO.url);
    for (const user of repoBefore.users.canAuthorise) {
      await db.removeUserCanAuthorise(repoIds[0], user);
    }

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', `${cookie}`)
      .send({ username: 'u1' });

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canAuthorise.length).toBe(1);
    expect(repo.users.canAuthorise[0]).toBe('u1');
  });

  it('add 2nd can authorise user', async () => {
    await ensureTestRepoExists();

    // Ensure u1 is already an authorise user
    await ensureUsersCanAuthorise(['u1']);

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', cookie)
      .send({ username: 'u2' });

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canAuthorise).toContain('u1');
    expect(repo.users.canAuthorise).toContain('u2');
    expect(repo.users.canAuthorise.length).toBe(2);
  });

  it('add authorise user that does not exist', async () => {
    await ensureTestRepoExists();

    // Ensure 2 authorise users exist
    await ensureUsersCanAuthorise(['u1', 'u2']);

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', cookie)
      .send({ username: 'u3' });

    expect(res.status).toBe(400);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canAuthorise.length).toBe(2);
  });

  it('Can delete u2 user', async () => {
    await ensureTestRepoExists();

    // Ensure u1 and u2 are authorise users
    await ensureUsersCanAuthorise(['u1', 'u2']);

    const res = await request(app)
      .delete(`/api/v1/repo/${repoIds[0]}/user/authorise/u2`)
      .set('Cookie', cookie)
      .send();

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    expect(repo.users.canAuthorise.length).toBe(1);
  });

  it('Valid user push permission on repo', async () => {
    await ensureTestRepoExists();

    // Add u2 as authorise user
    await db.addUserCanPush(repoIds[0], 'u2');

    const res = await request(app)
      .patch(`/api/v1/repo/${repoIds[0]}/user/authorise`)
      .set('Cookie', cookie)
      .send({ username: 'u2' });

    expect(res.status).toBe(200);
    const isAllowed = await db.isUserPushAllowed(TEST_REPO.url, 'u2');
    expect(isAllowed).toBe(true);
  });

  it('Invalid user push permission on repo', async () => {
    await ensureTestRepoExists();
    const isAllowed = await db.isUserPushAllowed(TEST_REPO.url, 'test1234');
    expect(isAllowed).toBe(false);
  });

  it('Proxy route helpers should return the proxied origin', async () => {
    await ensureTestRepoExists();
    const origins = await getAllProxiedHosts();
    expect(origins).toContain(TEST_REPO.host);
  });

  it('Proxy route helpers should return the new proxied origins when new repos are added', async () => {
    await ensureTestRepoExists();
    await cleanupRepo(TEST_REPO_NON_GITHUB.url);
    await cleanupRepo(TEST_REPO_NAKED.url);

    const res = await request(app)
      .post('/api/v1/repo')
      .set('Cookie', cookie)
      .send(TEST_REPO_NON_GITHUB);

    expect(res.status).toBe(200);
    const repo = await fetchRepoOrThrow(TEST_REPO_NON_GITHUB.url);
    repoIds[1] = repo._id!;

    expect(repo.project).toBe(TEST_REPO_NON_GITHUB.project);
    expect(repo.name).toBe(TEST_REPO_NON_GITHUB.name);
    expect(repo.url).toBe(TEST_REPO_NON_GITHUB.url);
    expect(repo.users.canPush.length).toBe(0);
    expect(repo.users.canAuthorise.length).toBe(0);

    const origins = await getAllProxiedHosts();
    expect(origins).toEqual(expect.arrayContaining([TEST_REPO.host, TEST_REPO_NON_GITHUB.host]));

    const res2 = await request(app)
      .post('/api/v1/repo')
      .set('Cookie', cookie)
      .send(TEST_REPO_NAKED);

    expect(res2.status).toBe(200);
    const repo2 = await fetchRepoOrThrow(TEST_REPO_NAKED.url);
    repoIds[2] = repo2._id!;

    const origins2 = await getAllProxiedHosts();
    expect(origins2).toEqual(
      expect.arrayContaining([TEST_REPO.host, TEST_REPO_NON_GITHUB.host, TEST_REPO_NAKED.host]),
    );
  });

  it('delete a repo', async () => {
    // Ensure repos exist before deleting
    let repo1 = await db.getRepoByUrl(TEST_REPO_NON_GITHUB.url);
    if (!repo1) {
      await request(app).post('/api/v1/repo').set('Cookie', cookie).send(TEST_REPO_NON_GITHUB);
      repo1 = await db.getRepoByUrl(TEST_REPO_NON_GITHUB.url);
    }
    repoIds[1] = repo1!._id!;

    let repo2 = await db.getRepoByUrl(TEST_REPO_NAKED.url);
    if (!repo2) {
      await request(app).post('/api/v1/repo').set('Cookie', cookie).send(TEST_REPO_NAKED);
      repo2 = await db.getRepoByUrl(TEST_REPO_NAKED.url);
    }
    repoIds[2] = repo2!._id!;

    const res = await request(app)
      .delete(`/api/v1/repo/${repoIds[1]}/delete`)
      .set('Cookie', cookie)
      .send();

    expect(res.status).toBe(200);
    const deletedRepo1 = await db.getRepoByUrl(TEST_REPO_NON_GITHUB.url);
    expect(deletedRepo1).toBeNull();

    const res2 = await request(app)
      .delete(`/api/v1/repo/${repoIds[2]}/delete`)
      .set('Cookie', cookie)
      .send();

    expect(res2.status).toBe(200);
    const deletedRepo2 = await db.getRepoByUrl(TEST_REPO_NAKED.url);
    expect(deletedRepo2).toBeNull();
  });

  afterAll(async () => {
    await proxy.stop();
    await Service.stop();
    await cleanupRepo(TEST_REPO_NON_GITHUB.url);
    await cleanupRepo(TEST_REPO_NAKED.url);
  });
});

describe('repo routes - edge cases', () => {
  let app: any;
  let proxy: any;
  let adminCookie: string;
  let nonAdminCookie: string;
  let repoId: string;

  const setCookie = function (res: any, cookieVar: 'admin' | 'nonAdmin') {
    res.headers['set-cookie'].forEach((x: string) => {
      if (x.startsWith('connect')) {
        const value = x.split(';')[0];
        if (cookieVar === 'admin') {
          adminCookie = value;
        } else {
          nonAdminCookie = value;
        }
      }
    });
  };

  beforeAll(async () => {
    proxy = new Proxy();
    app = await Service.start(proxy);

    await cleanupRepo(TEST_REPO.url);
    await db.deleteUser('testadmin');
    await db.deleteUser('nonadmin');

    await db.createUser('testadmin', 'password', 'testadmin@test.com', 'Test Admin', true);
    await db.createUser('nonadmin', 'password', 'nonadmin@test.com', 'Non Admin', false);

    // Login as admin and set cookies
    const adminRes = await request(app).post('/api/auth/login').send({
      username: 'admin',
      password: 'admin',
    });
    setCookie(adminRes, 'admin');

    // Login as non-admin and set cookies
    const nonAdminRes = await request(app).post('/api/auth/login').send({
      username: 'nonadmin',
      password: 'password',
    });
    setCookie(nonAdminRes, 'nonAdmin');

    // Create a test repo
    await request(app).post('/api/v1/repo').set('Cookie', adminCookie).send(TEST_REPO);

    const repo = await fetchRepoOrThrow(TEST_REPO.url);
    repoId = repo._id!;
  });

  it('should return 401 when non-admin user tries to create repo', async () => {
    const res = await request(app).post('/api/v1/repo').set('Cookie', nonAdminCookie).send({
      url: 'https://github.com/test/unauthorized-repo.git',
      name: 'unauthorized-repo',
      project: 'test',
      host: 'github.com',
    });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  it('should return 401 when unauthenticated user tries to create repo', async () => {
    const res = await request(app).post('/api/v1/repo').send({
      url: 'https://github.com/test/unauthenticated-repo.git',
      name: 'unauthenticated-repo',
      project: 'test',
      host: 'github.com',
    });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  it('should return 400 when repo url is missing', async () => {
    const res = await request(app).post('/api/v1/repo').set('Cookie', adminCookie).send({
      name: 'no-url-repo',
      project: 'test',
      host: 'github.com',
    });

    expect(res.status).toBe(400);
    expect(res.body.message).toBe('Repository url is required');
  });

  it('should return 400 when repo url is invalid', async () => {
    const res = await request(app).post('/api/v1/repo').set('Cookie', adminCookie).send({
      url: '',
      name: 'invalid-repo',
      project: 'test',
      host: 'github.com',
    });
    expect(res.status).toBe(400);
    expect(res.body.message).toBe('Repository url is required');
  });

  it('should return 401 when non-admin user tries to add push user', async () => {
    const res = await request(app)
      .patch(`/api/v1/repo/${repoId}/user/push`)
      .set('Cookie', nonAdminCookie)
      .send({ username: 'testuser' });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  it('should return 401 when unauthenticated user tries to add push user', async () => {
    const res = await request(app)
      .patch(`/api/v1/repo/${repoId}/user/push`)
      .send({ username: 'testuser' });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  it('should return 401 when non-admin user tries to add authorise user', async () => {
    const res = await request(app)
      .patch(`/api/v1/repo/${repoId}/user/authorise`)
      .set('Cookie', nonAdminCookie)
      .send({ username: 'testuser' });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  it('should return 401 when unauthenticated user tries to add authorise user', async () => {
    const res = await request(app)
      .patch(`/api/v1/repo/${repoId}/user/authorise`)
      .send({ username: 'testuser' });

    expect(res.status).toBe(401);
    expect(res.body.message).toBe('You are not authorised to perform this action...');
  });

  describe('DELETE /api/v1/repo/:id/user/push/:username', () => {
    beforeAll(async () => {
      // Add a user to remove
      await db.addUserCanPush(repoId, 'testuser');
    });

    it('should return 401 when non-admin user tries to remove push user', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/user/push/testuser`)
        .set('Cookie', nonAdminCookie)
        .send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });

    it('should return 401 when unauthenticated user tries to remove push user', async () => {
      const res = await request(app).delete(`/api/v1/repo/${repoId}/user/push/testuser`).send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });

    it('should return 400 when trying to remove non-existent user', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/user/push/nonexistentuser`)
        .set('Cookie', adminCookie)
        .send();

      expect(res.status).toBe(400);
      expect(res.body.error).toBe('User does not exist');
    });
  });

  describe('DELETE /api/v1/repo/:id/user/authorise/:username', () => {
    beforeAll(async () => {
      // Add a user to remove
      await db.addUserCanAuthorise(repoId, 'testuser');
    });

    it('should return 401 when non-admin user tries to remove authorise user', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/user/authorise/testuser`)
        .set('Cookie', nonAdminCookie)
        .send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });

    it('should return 401 when unauthenticated user tries to remove authorise user', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/user/authorise/testuser`)
        .send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });

    it('should return 400 when trying to remove non-existent user', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/user/authorise/nonexistentuser`)
        .set('Cookie', adminCookie)
        .send();

      expect(res.status).toBe(400);
      expect(res.body.error).toBe('User does not exist');
    });
  });

  describe('DELETE /api/v1/repo/:id/delete', () => {
    it('should return 401 when non-admin user tries to delete repo', async () => {
      const res = await request(app)
        .delete(`/api/v1/repo/${repoId}/delete`)
        .set('Cookie', nonAdminCookie)
        .send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });

    it('should return 401 when unauthenticated user tries to delete repo', async () => {
      const res = await request(app).delete(`/api/v1/repo/${repoId}/delete`).send();

      expect(res.status).toBe(401);
      expect(res.body.message).toBe('You are not authorised to perform this action...');
    });
  });

  describe('query params handling', () => {
    it('should handle boolean query params correctly', async () => {
      const res = await request(app)
        .get('/api/v1/repo')
        .set('Cookie', adminCookie)
        .query({ someFlag: 'true' });

      expect(res.status).toBe(200);
    });

    it('should ignore limit and skip query params in filtering', async () => {
      const res = await request(app)
        .get('/api/v1/repo')
        .set('Cookie', adminCookie)
        .query({ limit: '10', skip: '5' });

      expect(res.status).toBe(200);
    });

    it('should handle empty query params', async () => {
      const res = await request(app)
        .get('/api/v1/repo')
        .set('Cookie', adminCookie)
        .query({ '': 'empty' });

      expect(res.status).toBe(200);
    });
  });

  afterAll(async () => {
    await cleanupRepo(TEST_REPO.url);
    await db.deleteUser('testuser');
    await db.deleteUser('nonadmin');
    await Service.httpServer.close();
  });
});
